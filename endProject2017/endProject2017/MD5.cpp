#include <iomanip>
#include <sstream>

#include "MD5.h"

// Constants for hash, generated by (int)( (1<<32)*abs(sin(i+1)) )
const unsigned int k[64] = { 
0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 };

// Amount of rotations per round
const unsigned int s[64] = {
7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,
4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21 };

// Helper functions
#define MD5F(b,c,d) (   ((b) & (c)) | ((~(b)) & (d))   )
#define MD5G(b,c,d) MD5F((d),(b),(c))
#define MD5H(b,c,d) (   (b)^(c)^(d)   )
#define MD5I(b,c,d) (   (c) ^ ((b) | (~(d)))   )
// Rotate left
#define MD5R(x,r)   (   ((x)<<(r)) | ((x)>>(32-(r)))   )

// Calculate a single block
void MD5block(unsigned int* state, unsigned int* block)
{
	unsigned int a = state[0];
	unsigned int b = state[1];
	unsigned int c = state[2];
	unsigned int d = state[3];
	unsigned int tmp, i;

	for (i = 0; i < 16; i++)
	{
		tmp = a + MD5F(b, c, d) + k[i] + block[i];
		tmp = MD5R(tmp, s[i]);
		a = d;
		d = c;
		c = b;
		b += tmp;
	}
	for (i = 0; i < 16; i++)
	{
		tmp = a + MD5G(b, c, d) + k[i+16] + block[(5*i+1)%16];
		tmp = MD5R(tmp, s[i+16]);
		a = d;
		d = c;
		c = b;
		b += tmp;
	}
	for (i = 0; i < 16; i++)
	{
		tmp = a + MD5H(b, c, d) + k[i+32] + block[(3*i+5)%16];
		tmp = MD5R(tmp, s[i + 32]);
		a = d;
		d = c;
		c = b;
		b += tmp;
	}
	for (i = 0; i < 16; i++)
	{
		tmp = a + MD5I(b, c, d) + k[i+48] + block[(7*i)%16];
		tmp = MD5R(tmp, s[i + 48]);
		a = d;
		d = c;
		c = b;
		b += tmp;
	}
	state[0] += a;
	state[1] += b;
	state[2] += c;
	state[3] += d;
}

std::string MD5(const std::string& s)
{
	unsigned int len = s.size();
	// Total length (in bytes) must be divisible by 64, and have enough space
	// for the message, a terminating byte (0x80) and the length of the message (8 bytes).
	unsigned int paddedLen = len + 9;
	if (paddedLen % 64) paddedLen += 64 - paddedLen % 64;
	// Allocate memory for padding
	unsigned char* padded = new unsigned char[paddedLen];

	// Copy the message
	memcpy(padded, s.c_str(), len);
	// Put the terminating byte at the end
	padded[len] = 0x80;
	// Add padding
	memset(padded + len + 1, 0, paddedLen - len - 1);
	// Write length. Note that in this implementation, the length is only 32 bits, and the high 32 bits are 0.
	*(unsigned int*)(padded + paddedLen - 8) = 8*len;

	// Initialize state
	unsigned int i, state[4] = { 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476 };
	// Split the message into 64-byte blocks and calulate the hash of each block.
	for (i = 0; i < paddedLen; i += 64)
		MD5block(state, (unsigned int*)(padded + i));

	// Convert to hex
	std::stringstream stream;
	stream << std::hex << std::setfill('0');
	for (i = 0; i < 4; i++)
	{
		stream << std::setw(2) << ((state[i] >> 0) & 0xFF);
		stream << std::setw(2) << ((state[i] >> 8) & 0xFF);
		stream << std::setw(2) << ((state[i] >> 16) & 0xFF);
		stream << std::setw(2) << ((state[i] >> 24) & 0xFF);
	}

	delete padded;
	return stream.str();
}